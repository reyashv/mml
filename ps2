import numpy as np
import matplotlib.pyplot as plt

# ------------------ Manual Statistical Tests ------------------
def manual_t_test(residuals):
    n = len(residuals)
    mean_res = np.mean(residuals)
    std_res = np.std(residuals, ddof=1)
    if std_res == 0:
        return "Undefined (all residuals zero)"
    return mean_res / (std_res / np.sqrt(n))

def manual_z_test(residuals):
    n = len(residuals)
    mean_res = np.mean(residuals)
    std_res = np.std(residuals, ddof=0)
    if std_res == 0:
        return "Undefined (all residuals zero)"
    return mean_res / (std_res / np.sqrt(n))

# ------------------ Random Dataset ------------------
np.random.seed(42)
x_data = np.linspace(0, 10, 8)                 
y_data = np.sin(x_data) + np.random.normal(0, 0.1, len(x_data))  

x_predict = np.linspace(1, 9, 5)

true_vals = np.sin(x_predict)

# ============================================================== 
# 1. Newton Forward & Backward
# ============================================================== 
def newton_forward(x, x_data, y_data, n):
    h = x_data[1] - x_data[0]
    u = (x - x_data[0]) / h
    result = y_data[0]
    binomial = 1.0
    y_data_local = y_data.copy()
    for i in range(1, min(n, len(y_data))):
        binomial *= (u - (i - 1)) / i
        diff = np.diff(y_data_local)
        if len(diff) == 0:
            break
        result += binomial * diff[0]
        y_data_local = diff
    return result

def newton_backward(x, x_data, y_data, n):
    h = x_data[1] - x_data[0]
    u = (x - x_data[-1]) / h
    result = y_data[-1]
    binomial = 1.0
    y_data_local = y_data.copy()
    for i in range(1, min(n, len(y_data))):
        binomial *= (u + (i - 1)) / i
        diff = np.diff(y_data_local)[::-1]
        if len(diff) == 0:
            break
        result += binomial * diff[0]
        y_data_local = diff[::-1]
    return result

pred_forward = [newton_forward(x, x_data, y_data, len(x_data)) for x in x_predict]
pred_backward = [newton_backward(x, x_data, y_data, len(x_data)) for x in x_predict]

res_forward = np.array(pred_forward) - true_vals
res_backward = np.array(pred_backward) - true_vals

print("\n--- Newton Forward ---")
print("Predictions:", pred_forward)
print("t-test:", manual_t_test(res_forward))
print("z-test:", manual_z_test(res_forward))

print("\n--- Newton Backward ---")
print("Predictions:", pred_backward)
print("t-test:", manual_t_test(res_backward))
print("z-test:", manual_z_test(res_backward))

# ============================================================== 
# 2. Divided Difference
# ============================================================== 
def newton_divided_diff(x, y):
    n = len(y)
    coef = np.zeros([n, n])
    coef[:, 0] = y
    for j in range(1, n):
        for i in range(n - j):
            coef[i][j] = (coef[i+1][j-1] - coef[i][j-1]) / (x[i+j] - x[i])
    return coef[0, :]

def newton_poly(coef, x_data, x):
    n = len(x_data) - 1
    p = coef[n]
    for i in range(1, n + 1):
        p = coef[n-i] + (x - x_data[n-i]) * p
    return p

coeffs = newton_divided_diff(x_data, y_data)
pred_divdiff = [newton_poly(coeffs, x_data, x) for x in x_predict]
res_divdiff = np.array(pred_divdiff) - true_vals

print("\n--- Newton Divided Difference ---")
print("Predictions:", pred_divdiff)
print("t-test:", manual_t_test(res_divdiff))
print("z-test:", manual_z_test(res_divdiff))

# ============================================================== 
# 3. Lagrange
# ============================================================== 
def lagrange_interpolation(x, x_data, y_data):
    n = len(x_data)
    p = 0
    for i in range(n):
        term = y_data[i]
        for j in range(n):
            if j != i:
                term *= (x - x_data[j]) / (x_data[i] - x_data[j])
        p += term
    return p

pred_lagrange = [lagrange_interpolation(x, x_data, y_data) for x in x_predict]
res_lagrange = np.array(pred_lagrange) - true_vals

print("\n--- Lagrange ---")
print("Predictions:", pred_lagrange)
print("t-test:", manual_t_test(res_lagrange))
print("z-test:", manual_z_test(res_lagrange))

# ============================================================== 
# 4. Cubic Spline
# ============================================================== 
def cubic_spline_coeffs(x, y):
    n = len(x)
    h = np.diff(x)
    A = np.zeros((n, n))
    b = np.zeros(n)
    A[0,0] = A[-1,-1] = 1
    for i in range(1, n-1):
        A[i,i-1] = h[i-1]
        A[i,i] = 2 * (h[i-1] + h[i])
        A[i,i+1] = h[i]
        b[i] = 6*((y[i+1]-y[i])/h[i] - (y[i]-y[i-1])/h[i-1])
    M = np.linalg.solve(A,b)
    return M

def cubic_spline_interp(x_data, y_data, M, x):
    for i in range(len(x_data)-1):
        if x_data[i] <= x <= x_data[i+1]:
            h = x_data[i+1] - x_data[i]
            A = (x_data[i+1]-x)/h
            B = (x-x_data[i])/h
            C = (1/6)*(A**3 - A)*h**2
            D = (1/6)*(B**3 - B)*h**2
            return A*y_data[i] + B*y_data[i+1] + C*M[i] + D*M[i+1]
    return None

M = cubic_spline_coeffs(x_data, y_data)
pred_spline = [cubic_spline_interp(x_data, y_data, M, x) for x in x_predict]
res_spline = np.array(pred_spline) - true_vals

print("\n--- Cubic Spline ---")
print("Predictions:", pred_spline)
print("t-test:", manual_t_test(res_spline))
print("z-test:", manual_z_test(res_spline))

# ============================================================== 
# Plot all together
# ============================================================== 
plt.figure(figsize=(10,6))
plt.scatter(x_data, y_data, color="black", label="Data points")

x_dense = np.linspace(min(x_data), max(x_data), 200)
y_forward = [newton_forward(x, x_data, y_data, len(x_data)) for x in x_dense]
y_backward = [newton_backward(x, x_data, y_data, len(x_data)) for x in x_dense]
y_divdiff = [newton_poly(coeffs, x_data, x) for x in x_dense]
y_lagrange = [lagrange_interpolation(x, x_data, y_data) for x in x_dense]
y_spline = [cubic_spline_interp(x_data, y_data, M, x) for x in x_dense]

plt.plot(x_dense, y_forward, label="Forward", color="blue")
plt.plot(x_dense, y_backward, label="Backward", color="green")
plt.plot(x_dense, y_divdiff, label="Divided Diff", color="orange")
plt.plot(x_dense, y_lagrange, label="Lagrange", linestyle="--", color="purple")
plt.plot(x_dense, y_spline, label="Cubic Spline", linestyle=":", color="red")

plt.scatter(x_predict, pred_spline, marker="*", s=120, color="red", label="Predictions (all methods)")
plt.legend()
plt.xlabel("x")
plt.ylabel("y")
plt.title("Comparison of Interpolation Methods")
plt.grid(True)
plt.show()
