import numpy as np
import matplotlib.pyplot as plt

# ------------------ Manual Statistical Tests ------------------
def manual_t_test(residuals):
    n = len(residuals)
    mean_res = np.mean(residuals)
    std_res = np.std(residuals, ddof=1)
    if std_res == 0:
        return "Undefined (all residuals zero)"
    t_stat = mean_res / (std_res / np.sqrt(n))
    return t_stat

def manual_z_test(residuals):
    n = len(residuals)
    mean_res = np.mean(residuals)
    std_res = np.std(residuals, ddof=0)
    if std_res == 0:
        return "Undefined (all residuals zero)"
    z_stat = mean_res / (std_res / np.sqrt(n))
    return z_stat

# ==============================================================
# Data for all problems
# ==============================================================

# 1. Forward & Backward (Force vs Stretch)
force = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90])
stretch = np.array([19, 57, 94, 134, 173, 216, 256, 297, 343])

# 2. Divided Difference & Lagrange (Temperature vs Emittance)
T = np.array([300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900, 2000])
e = np.array([0.024, 0.035, 0.046, 0.058, 0.067, 0.083, 0.097, 0.111, 0.125, 0.140, 0.155, 0.170, 0.186, 0.202, 0.219, 0.235, 0.252, 0.269])

# 3. Cubic Spline (Temperature vs Oxygen)
temperature_data = np.array([0, 8, 16, 24, 32, 40], dtype=float)
oxygen_data = np.array([14.621, 11.843, 9.870, 8.418, 7.305, 6.413], dtype=float)

# ==============================================================
# 1. Newton Forward and Backward
# ==============================================================
def newton_forward(x, x_data, y_data, n):
    h = x_data[1] - x_data[0]
    u = (x - x_data[0]) / h
    result = y_data[0]
    binomial = 1.0
    y_data_local = y_data.copy()
    for i in range(1, min(n, len(y_data))):
        binomial *= (u - (i - 1)) / i
        diff = np.diff(y_data_local)
        if len(diff) == 0:
            break
        result += binomial * diff[0]
        y_data_local = diff
    return result

def newton_backward(x, x_data, y_data, n):
    h = x_data[1] - x_data[0]
    u = (x - x_data[-1]) / h
    result = y_data[-1]
    binomial = 1.0
    y_data_local = y_data.copy()
    for i in range(1, min(n, len(y_data))):
        binomial *= (u + (i - 1)) / i
        diff = np.diff(y_data_local)[::-1]
        if len(diff) == 0:
            break
        result += binomial * diff[0]
        y_data_local = diff[::-1]
    return result

forces_to_predict = [15, 17, 85]
pred_forward = [newton_forward(f, force, stretch, 9) for f in forces_to_predict]
pred_backward = [newton_backward(f, force, stretch, 9) for f in forces_to_predict]

true_vals_force = np.interp(forces_to_predict, force, stretch)
residuals_forward = np.array(pred_forward) - true_vals_force
residuals_backward = np.array(pred_backward) - true_vals_force

print("\n--- Newton Forward ---")
print("Predictions:", pred_forward)
print("t-test:", manual_t_test(residuals_forward))
print("z-test:", manual_z_test(residuals_forward))

print("\n--- Newton Backward ---")
print("Predictions:", pred_backward)
print("t-test:", manual_t_test(residuals_backward))
print("z-test:", manual_z_test(residuals_backward))

# ==============================================================
# 2. Divided Difference
# ==============================================================
def newton_divided_diff(x, y):
    n = len(y)
    coef = np.zeros([n, n])
    coef[:, 0] = y
    for j in range(1, n):
        for i in range(n - j):
            coef[i][j] = (coef[i+1][j-1] - coef[i][j-1]) / (x[i+j] - x[i])
    return coef[0, :]

def newton_poly(coef, x_data, x):
    n = len(x_data) - 1
    p = coef[n]
    for i in range(1, n + 1):
        p = coef[n-i] + (x - x_data[n-i]) * p
    return p

newton_coeffs = newton_divided_diff(T, e)
T_predict = [550, 1050, 1750]
pred_divdiff = [newton_poly(newton_coeffs, T, t) for t in T_predict]

true_vals_T = np.interp(T_predict, T, e)
residuals_divdiff = np.array(pred_divdiff) - true_vals_T

print("\n--- Newton Divided Difference ---")
print("Predictions:", pred_divdiff)
print("t-test:", manual_t_test(residuals_divdiff))
print("z-test:", manual_z_test(residuals_divdiff))

# ==============================================================
# 3. Lagrange
# ==============================================================
def lagrange_interpolation(x, x_data, y_data):
    n = len(x_data)
    p = 0
    for i in range(n):
        term = y_data[i]
        for j in range(n):
            if j != i:
                term *= (x - x_data[j]) / (x_data[i] - x_data[j])
        p += term
    return p

pred_lagrange = [lagrange_interpolation(t, T, e) for t in T_predict]
residuals_lagrange = np.array(pred_lagrange) - true_vals_T

print("\n--- Lagrange ---")
print("Predictions:", pred_lagrange)
print("t-test:", manual_t_test(residuals_lagrange))
print("z-test:", manual_z_test(residuals_lagrange))

# ==============================================================
# 4. Cubic Spline
# ==============================================================
num_points = len(temperature_data)
h = np.diff(temperature_data)
num_unknowns = num_points - 2
A = np.zeros((num_unknowns, num_unknowns))
b_vec = np.zeros(num_unknowns)

for i in range(num_unknowns):
    A[i, i] = 2 * (h[i] + h[i+1])
    if i < num_unknowns - 1:
        A[i, i+1] = h[i+1]
    if i > 0:
        A[i, i-1] = h[i]
    b_vec[i] = 6 * ((oxygen_data[i+2] - oxygen_data[i+1]) / h[i+1] - (oxygen_data[i+1] - oxygen_data[i]) / h[i])

second_derivs_interior = np.linalg.solve(A, b_vec)
second_derivs_full = np.concatenate(([0], second_derivs_interior, [0]))

def cubic_spline_interp(T_data, o_data, M_vals, T_val):
    for i in range(len(T_data) - 1):
        if T_data[i] <= T_val <= T_data[i+1]:
            h_i = T_data[i+1] - T_data[i]
            x_minus_ti = T_val - T_data[i]
            ti_plus_1_minus_x = T_data[i+1] - T_val
            term1 = M_vals[i] / (6 * h_i) * ti_plus_1_minus_x**3
            term2 = M_vals[i+1] / (6 * h_i) * x_minus_ti**3
            term3 = (o_data[i+1] / h_i - M_vals[i+1] * h_i / 6) * x_minus_ti
            term4 = (o_data[i] / h_i - M_vals[i] * h_i / 6) * ti_plus_1_minus_x
            return term1 + term2 + term3 + term4
    return None

T_predict_spline = [12, 20, 36]
pred_spline = [cubic_spline_interp(temperature_data, oxygen_data, second_derivs_full, t) for t in T_predict_spline]
true_vals_spline = np.interp(T_predict_spline, temperature_data, oxygen_data)
residuals_spline = np.array(pred_spline) - true_vals_spline

print("\n--- Cubic Spline ---")
print("Predictions:", pred_spline)
print("t-test:", manual_t_test(residuals_spline))
print("z-test:", manual_z_test(residuals_spline))
