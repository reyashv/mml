// Divided difference, forward, backward, lagrange, cubic spline
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats

force = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90])
stretch = np.array([19, 57, 94, 134, 173, 216, 256, 297, 343])

# Newton Forward Interpolation 
def newton_forward(x, x_data, y_data, n):
    h = x_data[1] - x_data[0]
    u = (x - x_data[0]) / h
    result = y_data[0]
    binomial = 1.0
    y_data_local = y_data.copy()
    for i in range(1, min(n, len(y_data))):
        binomial *= (u - (i - 1)) / i
        diff = np.diff(y_data_local)
        if len(diff) == 0:
            break
        result += binomial * diff[-1]
        y_data_local = diff
    return result

def newton_backward(x, x_data, y_data, n):
    h = x_data[1] - x_data[0]  
    u = (x - x_data[-1]) / h   
    result = y_data[-1]        
    binomial = 1.0             
    y_data_local = y_data.copy()  
    for i in range(1, min(n, len(y_data))):
        binomial *= (u + (i - 1)) / i 
        diff = np.diff(y_data_local)[::-1]  
        if len(diff) == 0:
            break
        result += binomial * diff[0]  
        y_data_local = diff[::-1]     
    return result

# Forward differences (up to 8th order for 9 points)
diff_table = np.zeros((9, 9))
diff_table[:, 0] = stretch
for i in range(1, 9):
    diff_table[:9-i, i] = np.diff(diff_table[:9-i+1, i-1])
print(diff_table)

# Interpolating polynomial coefficients (first row of differences)
coeffs = diff_table[0, 1:]

# Evaluate at specific points
forces_to_predict = [15, 17, 85]
predicted_stretch = [newton_forward(f, force, stretch, 9) for f in forces_to_predict]

# Plot
x_range = np.linspace(min(force), max(force), 100)
y_interp = [newton_forward(x, force, stretch, 9) for x in x_range]

plt.figure(figsize=(10, 5))
plt.plot(force, stretch, 'ro', label='Data Points')
plt.plot(x_range, y_interp, 'b-', label='Interpolating Polynomial')
for f, s in zip(forces_to_predict, predicted_stretch):
    plt.plot(f, s, 'go', label=f'Force {f} (Stretch {s:.2f})')
plt.xlabel('Force')
plt.ylabel('Stretch')
plt.title('Stretch vs Force with Interpolating Polynomial')
plt.legend()
plt.grid(True)
plt.show()

# (b) Errors (at data points, error is 0 by construction)
errors = np.zeros_like(stretch)
plt.figure(figsize=(10, 5))
plt.plot(force, errors, 'go-', label='Errors')
plt.axhline(0, color='r', linestyle='--', label='Zero Error')
plt.xlabel('Force')
plt.ylabel('Error')
plt.title('Errors in Interpolation')
plt.legend()
plt.grid(True)
plt.show()

# (c) Manual linear regression and t-test with built-in function
n = len(force)
mean_x = np.mean(force)
mean_y = np.mean(stretch)
ss_xx = np.sum((force - mean_x) ** 2)
ss_xy = np.sum((force - mean_x) * (stretch - mean_y))
slope = ss_xy / ss_xx
intercept = mean_y - slope * mean_x
predicted = intercept + slope * force
residuals = stretch - predicted
ss_res = np.sum(residuals ** 2)
ss_tot = np.sum((stretch - mean_y) ** 2)
r_squared = 1 - (ss_res / ss_tot)

# t-test on residuals using built-in function
t_stat, p_val = stats.ttest_1samp(residuals, 0)

print(f"Linear Model: y = {intercept:.2f} + {slope:.2f}x")
print(f"R² = {r_squared:.3f}")
print(f"t-statistic for residuals mean = {t_stat:.2f}, p-value = {p_val:.3f}")
print(f"Predicted stretches: {dict(zip(forces_to_predict, [f'{s:.2f}' for s in predicted_stretch]))}")


import numpy as np
import matplotlib.pyplot as plt

# Data
T = np.array([300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900, 2000])
e = np.array([0.024, 0.035, 0.046, 0.058, 0.067, 0.083, 0.097, 0.111, 0.125, 0.140, 0.155, 0.170, 0.186, 0.202, 0.219, 0.235, 0.252, 0.269])

# Original function
def original_emittance(T):
    return 0.02424 * (T / 303.16) ** 1.27591

# Newton Divided Difference Interpolation
def newton_divided_diff(x, y):
    n = len(y)
    coef = np.zeros([n, n])
    coef[:, 0] = y
    for j in range(1, n):
        for i in range(n - j):
            coef[i][j] = (coef[i+1][j-1] - coef[i][j-1]) / (x[i+j] - x[i])
    return coef[0, :]

def newton_poly(coef, x_data, x):
    n = len(x_data) - 1
    p = coef[n]
    for i in range(1, n + 1):
        p = coef[n-i] + (x - x_data[n-i]) * p
    return p

newton_coeffs = newton_divided_diff(T, e)
T_range = np.linspace(min(T), max(T), 200)
e_newton = [newton_poly(newton_coeffs, T, t) for t in T_range]

# Lagrange Interpolation
def lagrange_interpolation(x, x_data, y_data):
    n = len(x_data)
    p = 0
    for i in range(n):
        term = y_data[i]
        for j in range(n):
            if j != i:
                term *= (x - x_data[j]) / (x_data[i] - x_data[j])
        p += term
    return p

e_lagrange = [lagrange_interpolation(t, T, e) for t in T_range]

# Compute value at T = 500 (assuming 0.5 was a typo for 500)
T_predict = 500
e_newton_at_500 = newton_poly(newton_coeffs, T, T_predict)
e_lagrange_at_500 = lagrange_interpolation(T_predict, T, e)
e_original_at_500 = original_emittance(T_predict)

print(f"Emittance at T = 500 K:")
print(f"Newton Divided Difference: {e_newton_at_500:.6f}")
print(f"Lagrange Interpolation: {e_lagrange_at_500:.6f}")
print(f"Original Function: {e_original_at_500:.6f}")

# Plot
plt.figure(figsize=(10, 6))
plt.plot(T, e, 'ro', label='Data Points')
plt.plot(T_range, e_newton, 'b-', label='Newton Interpolation')
plt.plot(T_range, e_lagrange, 'g--', label='Lagrange Interpolation')
T_original_range = np.linspace(min(T), max(T), 200)
e_original = original_emittance(T_original_range)
plt.plot(T_original_range, e_original, 'k-', label='Original Function')
plt.xlabel('Temperature (T, K)')
plt.ylabel('Emittance (e)')
plt.title('Emittance of Tungsten vs Temperature')
plt.legend()
plt.grid(True)
plt.show()


import numpy as np
import matplotlib.pyplot as plt

temperature_data = np.array([0, 8, 16, 24, 32, 40], dtype=float)
oxygen_data = np.array([14.621, 11.843, 9.870, 8.418, 7.305, 6.413], dtype=float)

num_points = len(temperature_data)
h = np.diff(temperature_data)

num_unknowns = num_points - 2
A = np.zeros((num_unknowns, num_unknowns))
b = np.zeros(num_unknowns)

for i in range(num_unknowns):
    A[i, i] = 2 * (h[i] + h[i+1])

    if i < num_unknowns - 1:
        A[i, i+1] = h[i+1]

    if i > 0:
        A[i, i-1] = h[i]

    b[i] = 6 * ((oxygen_data[i+2] - oxygen_data[i+1]) / h[i+1] - (oxygen_data[i+1] - oxygen_data[i]) / h[i])

second_derivs_interior = np.linalg.solve(A, b)
second_derivs_full = np.concatenate(([0], second_derivs_interior, [0]))

def cubic_spline_interp(T_data, o_data, M_vals, T_val):
    for i in range(len(T_data) - 1):
        if T_data[i] <= T_val <= T_data[i+1]:
            h_i = T_data[i+1] - T_data[i]
            x_minus_ti = T_val - T_data[i]
            ti_plus_1_minus_x = T_data[i+1] - T_val

            term1 = M_vals[i] / (6 * h_i) * ti_plus_1_minus_x**3
            term2 = M_vals[i+1] / (6 * h_i) * x_minus_ti**3
            term3 = (o_data[i+1] / h_i - M_vals[i+1] * h_i / 6) * x_minus_ti
            term4 = (o_data[i] / h_i - M_vals[i] * h_i / 6) * ti_plus_1_minus_x

            return term1 + term2 + term3 + term4
    return None

T_plot = np.linspace(temperature_data.min(), temperature_data.max(), 400)
oxygen_spline = [cubic_spline_interp(temperature_data, oxygen_data, second_derivs_full, temp) for temp in T_plot]

plt.figure(figsize=(10, 6))
plt.plot(temperature_data, oxygen_data, 'o', label='Original Data Points')
plt.plot(T_plot, oxygen_spline, '-', label='Cubic Spline Interpolation')
plt.title('Dissolved Oxygen Concentration vs. Temperature')
plt.xlabel('Temperature ($T$, °C)')
plt.ylabel('Dissolved Oxygen ($o$, mg/L)')
plt.legend()
plt.grid(True)
plt.show()
