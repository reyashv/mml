import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# ------------------ Manual Statistical Tests ------------------
def manual_t_test(residuals):
    n = len(residuals)
    mean_res = np.mean(residuals)
    std_res = np.std(residuals, ddof=1)
    if std_res == 0:
        return "Undefined"
    return mean_res / (std_res / np.sqrt(n))

def manual_z_test(residuals):
    n = len(residuals)
    mean_res = np.mean(residuals)
    std_res = np.std(residuals, ddof=0)
    if std_res == 0:
        return "Undefined"
    return mean_res / (std_res / np.sqrt(n))

# ------------------ Random Dataset ------------------
np.random.seed(42)
x_data = np.linspace(0, 10, 8)                 
y_data = np.sin(x_data) + np.random.normal(0, 0.1, len(x_data))  

x_predict = np.linspace(1, 9, 5)
true_vals = np.sin(x_predict)

# ============================================================== 
# 1. Newton Forward & Backward
# ============================================================== 
def newton_forward(x, x_data, y_data, n):
    h = x_data[1] - x_data[0]
    u = (x - x_data[0]) / h
    result = y_data[0]
    binomial = 1.0
    y_data_local = y_data.copy()
    for i in range(1, min(n, len(y_data))):
        binomial *= (u - (i - 1)) / i
        diff = np.diff(y_data_local)
        if len(diff) == 0:
            break
        result += binomial * diff[0]
        y_data_local = diff
    return result

def newton_backward(x, x_data, y_data, n):
    h = x_data[1] - x_data[0]
    u = (x - x_data[-1]) / h
    result = y_data[-1]
    binomial = 1.0
    y_data_local = y_data.copy()
    for i in range(1, min(n, len(y_data))):
        binomial *= (u + (i - 1)) / i
        diff = np.diff(y_data_local)[::-1]
        if len(diff) == 0:
            break
        result += binomial * diff[0]
        y_data_local = diff[::-1]
    return result

# ============================================================== 
# 2. Divided Difference
# ============================================================== 
def newton_divided_diff(x, y):
    n = len(y)
    coef = np.zeros([n, n])
    coef[:, 0] = y
    for j in range(1, n):
        for i in range(n - j):
            coef[i][j] = (coef[i+1][j-1] - coef[i][j-1]) / (x[i+j] - x[i])
    return coef[0, :]

def newton_poly(coef, x_data, x):
    n = len(x_data) - 1
    p = coef[n]
    for i in range(1, n + 1):
        p = coef[n-i] + (x - x_data[n-i]) * p
    return p

# ============================================================== 
# 3. Lagrange
# ============================================================== 
def lagrange_interpolation(x, x_data, y_data):
    n = len(x_data)
    p = 0
    for i in range(n):
        term = y_data[i]
        for j in range(n):
            if j != i:
                term *= (x - x_data[j]) / (x_data[i] - x_data[j])
        p += term
    return p

# ============================================================== 
# 4. Cubic Spline
# ============================================================== 
def cubic_spline_coeffs(x, y):
    n = len(x)
    h = np.diff(x)
    A = np.zeros((n, n))
    b = np.zeros(n)
    A[0,0] = A[-1,-1] = 1
    for i in range(1, n-1):
        A[i,i-1] = h[i-1]
        A[i,i] = 2 * (h[i-1] + h[i])
        A[i,i+1] = h[i]
        b[i] = 6*((y[i+1]-y[i])/h[i] - (y[i]-y[i-1])/h[i-1])
    M = np.linalg.solve(A,b)
    return M

def cubic_spline_interp(x_data, y_data, M, x):
    for i in range(len(x_data)-1):
        if x_data[i] <= x <= x_data[i+1]:
            h = x_data[i+1] - x_data[i]
            A = (x_data[i+1]-x)/h
            B = (x-x_data[i])/h
            C = (1/6)*(A**3 - A)*h**2
            D = (1/6)*(B**3 - B)*h**2
            return A*y_data[i] + B*y_data[i+1] + C*M[i] + D*M[i+1]
    return None

# ============================================================== 
# Tables: Forward, Backward, Divided Difference
# ============================================================== 
def forward_difference_table(x, y):
    n = len(y)
    table = np.zeros((n, n+1))
    table[:,0] = x
    table[:,1] = y
    for j in range(2, n+1):
        for i in range(n-j+1):
            table[i,j] = table[i+1,j-1] - table[i,j-1]
    return table

def backward_difference_table(x, y):
    n = len(y)
    table = np.zeros((n, n+1))
    table[:,0] = x
    table[:,1] = y
    for j in range(2, n+1):
        for i in range(j-1, n):
            table[i,j] = table[i,j-1] - table[i-1,j-1]
    return table

def divided_difference_table(x, y):
    n = len(y)
    table = np.zeros((n, n+1))
    table[:,0] = x
    table[:,1] = y
    for j in range(2, n+1):
        for i in range(n-j+1):
            table[i,j] = (table[i+1,j-1] - table[i,j-1]) / (x[i+j-1] - x[i])
    return table

# Generate Tables
fd_table = forward_difference_table(x_data, y_data)
bd_table = backward_difference_table(x_data, y_data)
dd_table = divided_difference_table(x_data, y_data)

print("\n===== Forward Difference Table =====")
print(pd.DataFrame(fd_table, columns=["x","y"] + [f"Δ^{i}y" for i in range(1,len(x_data))]).to_string(index=False, float_format="%.4f"))

print("\n===== Backward Difference Table =====")
print(pd.DataFrame(bd_table, columns=["x","y"] + [f"∇^{i}y" for i in range(1,len(x_data))]).to_string(index=False, float_format="%.4f"))

print("\n===== Divided Difference Table =====")
print(pd.DataFrame(dd_table, columns=["x","f[x]"] + [f"Order {i}" for i in range(2,len(x_data)+1)]).to_string(index=False, float_format="%.4f"))

# ============================================================== 
# Predictions + Residuals + Tests
# ============================================================== 
pred_forward = [newton_forward(x, x_data, y_data, len(x_data)) for x in x_predict]
pred_backward = [newton_backward(x, x_data, y_data, len(x_data)) for x in x_predict]

coeffs = newton_divided_diff(x_data, y_data)
pred_divdiff = [newton_poly(coeffs, x_data, x) for x in x_predict]

pred_lagrange = [lagrange_interpolation(x, x_data, y_data) for x in x_predict]

M = cubic_spline_coeffs(x_data, y_data)
pred_spline = [cubic_spline_interp(x_data, y_data, M, x) for x in x_predict]

# Residuals
res_forward = np.array(pred_forward) - true_vals
res_backward = np.array(pred_backward) - true_vals
res_divdiff = np.array(pred_divdiff) - true_vals
res_lagrange = np.array(pred_lagrange) - true_vals
res_spline = np.array(pred_spline) - true_vals

print("\n===== Statistical Tests =====")
for name, res in zip(
    ["Forward", "Backward", "Divided Diff", "Lagrange", "Cubic Spline"],
    [res_forward, res_backward, res_divdiff, res_lagrange, res_spline]
):
    print(f"\n--- {name} ---")
    print("t-test:", manual_t_test(res))
    print("z-test:", manual_z_test(res))

# ============================================================== 
# Plot for Comparison
# ============================================================== 
x_dense = np.linspace(min(x_data), max(x_data), 200)
y_forward = [newton_forward(x, x_data, y_data, len(x_data)) for x in x_dense]
y_backward = [newton_backward(x, x_data, y_data, len(x_data)) for x in x_dense]
y_divdiff = [newton_poly(coeffs, x_data, x) for x in x_dense]
y_lagrange = [lagrange_interpolation(x, x_data, y_data) for x in x_dense]
y_spline = [cubic_spline_interp(x_data, y_data, M, x) for x in x_dense]

plt.figure(figsize=(10,6))
plt.scatter(x_data, y_data, color="black", label="Data points")
plt.plot(x_dense, y_forward, label="Forward", color="blue")
plt.plot(x_dense, y_backward, label="Backward", color="green")
plt.plot(x_dense, y_divdiff, label="Divided Diff", color="orange")
plt.plot(x_dense, y_lagrange, label="Lagrange", linestyle="--", color="purple")
plt.plot(x_dense, y_spline, label="Cubic Spline", linestyle=":", color="red")
plt.legend()
plt.xlabel("x")
plt.ylabel("y")
plt.title("Comparison of Interpolation Methods")
plt.grid(True)
plt.show()
